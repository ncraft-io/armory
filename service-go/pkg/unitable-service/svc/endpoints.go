// Code generated by ncraft. DO NOT EDIT.
// Rerunning ncraft will overwrite this file.
// Version: 0.1.0
// Version Date:

package svc

// This file contains methods to make individual endpoints from services,
// request and response types to serve those endpoints, as well as encoders and
// decoders for those types, for all of our supported transport serialization
// formats.

import (
	"context"
	"fmt"

	"github.com/go-kit/kit/endpoint"

	"github.com/mojo-lang/core/go/pkg/mojo/core"
	"github.com/ncraft-io/armory/go/pkg/armory/unitable"

	// this service api
	pb "github.com/ncraft-io/armory/go/pkg/armory/unitable/v1"
)

var (
	_ = unitable.Table{}
	_ = core.Null{}
	_ = core.Ordering{}
	_ = core.FieldMask{}
	_ = unitable.Column{}
	_ = core.Object{}
)

// Endpoints collects all of the endpoints that compose an add service. It's
// meant to be used as a helper struct, to collect all of the endpoints into a
// single parameter.
//
// In a server, it's useful for functions that need to operate on a per-endpoint
// basis. For example, you might pass an Endpoints to a function that produces
// an http.Handler, with each method (endpoint) wired up to a specific path. (It
// is probably a mistake in design to invoke the Service methods on the
// Endpoints struct in a server.)
//
// In a client, it's useful to collect individually constructed endpoints into a
// single type that implements the Service interface. For example, you might
// construct individual endpoints using transport/http.NewClient, combine them into an Endpoints, and return it to the caller as a Service.
type Endpoints struct {
	CreateTableEndpoint        endpoint.Endpoint
	UpdateTableEndpoint        endpoint.Endpoint
	GetTableEndpoint           endpoint.Endpoint
	ListTablesEndpoint         endpoint.Endpoint
	DeleteTableEndpoint        endpoint.Endpoint
	SyncTableEndpoint          endpoint.Endpoint
	CreateColumnEndpoint       endpoint.Endpoint
	UpdateColumnEndpoint       endpoint.Endpoint
	GetColumnEndpoint          endpoint.Endpoint
	DeleteColumnEndpoint       endpoint.Endpoint
	ListColumnsEndpoint        endpoint.Endpoint
	BatchCreateColumnsEndpoint endpoint.Endpoint
	BatchUpdateColumnEndpoint  endpoint.Endpoint
	BatchDeleteColumnEndpoint  endpoint.Endpoint
	CreateRowEndpoint          endpoint.Endpoint
	UpdateRowEndpoint          endpoint.Endpoint
	GetRowEndpoint             endpoint.Endpoint
	DeleteRowEndpoint          endpoint.Endpoint
	ListRowEndpoint            endpoint.Endpoint
	ExportRowEndpoint          endpoint.Endpoint
	BatchCreateRowsEndpoint    endpoint.Endpoint
	BatchUpdateRowsEndpoint    endpoint.Endpoint
	BatchDeleteRowsEndpoint    endpoint.Endpoint
}

// Endpoints

func (e Endpoints) CreateTable(ctx context.Context, in *pb.CreateTableRequest) (*unitable.Table, error) {
	response, err := e.CreateTableEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*unitable.Table), nil
}

func (e Endpoints) UpdateTable(ctx context.Context, in *pb.UpdateTableRequest) (*core.Null, error) {
	response, err := e.UpdateTableEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) GetTable(ctx context.Context, in *pb.GetTableRequest) (*unitable.Table, error) {
	response, err := e.GetTableEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*unitable.Table), nil
}

func (e Endpoints) ListTables(ctx context.Context, in *pb.ListTablesRequest) (*pb.ListTablesResponse, error) {
	response, err := e.ListTablesEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.ListTablesResponse), nil
}

func (e Endpoints) DeleteTable(ctx context.Context, in *pb.DeleteTableRequest) (*core.Null, error) {
	response, err := e.DeleteTableEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) SyncTable(ctx context.Context, in *pb.SyncTableRequest) (*unitable.Table, error) {
	response, err := e.SyncTableEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*unitable.Table), nil
}

func (e Endpoints) CreateColumn(ctx context.Context, in *pb.CreateColumnRequest) (*unitable.Column, error) {
	response, err := e.CreateColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*unitable.Column), nil
}

func (e Endpoints) UpdateColumn(ctx context.Context, in *pb.UpdateColumnRequest) (*core.Null, error) {
	response, err := e.UpdateColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) GetColumn(ctx context.Context, in *pb.GetColumnRequest) (*unitable.Column, error) {
	response, err := e.GetColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*unitable.Column), nil
}

func (e Endpoints) DeleteColumn(ctx context.Context, in *pb.DeleteColumnRequest) (*core.Null, error) {
	response, err := e.DeleteColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) ListColumns(ctx context.Context, in *pb.ListColumnsRequest) (*pb.ListColumnsResponse, error) {
	response, err := e.ListColumnsEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.ListColumnsResponse), nil
}

func (e Endpoints) BatchCreateColumns(ctx context.Context, in *pb.BatchCreateColumnsRequest) (*core.Null, error) {
	response, err := e.BatchCreateColumnsEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) BatchUpdateColumn(ctx context.Context, in *pb.BatchUpdateColumnRequest) (*core.Null, error) {
	response, err := e.BatchUpdateColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) BatchDeleteColumn(ctx context.Context, in *pb.BatchDeleteColumnRequest) (*core.Null, error) {
	response, err := e.BatchDeleteColumnEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) CreateRow(ctx context.Context, in *pb.CreateRowRequest) (*core.Object, error) {
	response, err := e.CreateRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Object), nil
}

func (e Endpoints) UpdateRow(ctx context.Context, in *pb.UpdateRowRequest) (*core.Null, error) {
	response, err := e.UpdateRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) GetRow(ctx context.Context, in *pb.GetRowRequest) (*core.Object, error) {
	response, err := e.GetRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Object), nil
}

func (e Endpoints) DeleteRow(ctx context.Context, in *pb.DeleteRowRequest) (*core.Null, error) {
	response, err := e.DeleteRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) ListRow(ctx context.Context, in *pb.ListRowRequest) (*pb.ListRowResponse, error) {
	response, err := e.ListRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.ListRowResponse), nil
}

func (e Endpoints) ExportRow(ctx context.Context, in *pb.ExportRowRequest) (*pb.ExportRowResponse, error) {
	response, err := e.ExportRowEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*pb.ExportRowResponse), nil
}

func (e Endpoints) BatchCreateRows(ctx context.Context, in *pb.BatchCreateRowsRequest) (*core.Null, error) {
	response, err := e.BatchCreateRowsEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) BatchUpdateRows(ctx context.Context, in *pb.BatchUpdateRowsRequest) (*core.Null, error) {
	response, err := e.BatchUpdateRowsEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

func (e Endpoints) BatchDeleteRows(ctx context.Context, in *pb.BatchDeleteRowsRequest) (*core.Null, error) {
	response, err := e.BatchDeleteRowsEndpoint(ctx, in)
	if err != nil {
		return nil, err
	}
	return response.(*core.Null), nil
}

// Make Endpoints

func MakeCreateTableEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.CreateTableRequest)
		v, err := s.CreateTable(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeUpdateTableEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.UpdateTableRequest)
		v, err := s.UpdateTable(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetTableEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetTableRequest)
		v, err := s.GetTable(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeListTablesEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.ListTablesRequest)
		v, err := s.ListTables(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeDeleteTableEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.DeleteTableRequest)
		v, err := s.DeleteTable(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeSyncTableEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.SyncTableRequest)
		v, err := s.SyncTable(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeCreateColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.CreateColumnRequest)
		v, err := s.CreateColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeUpdateColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.UpdateColumnRequest)
		v, err := s.UpdateColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetColumnRequest)
		v, err := s.GetColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeDeleteColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.DeleteColumnRequest)
		v, err := s.DeleteColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeListColumnsEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.ListColumnsRequest)
		v, err := s.ListColumns(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchCreateColumnsEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchCreateColumnsRequest)
		v, err := s.BatchCreateColumns(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchUpdateColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchUpdateColumnRequest)
		v, err := s.BatchUpdateColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchDeleteColumnEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchDeleteColumnRequest)
		v, err := s.BatchDeleteColumn(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeCreateRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.CreateRowRequest)
		v, err := s.CreateRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeUpdateRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.UpdateRowRequest)
		v, err := s.UpdateRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeGetRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.GetRowRequest)
		v, err := s.GetRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeDeleteRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.DeleteRowRequest)
		v, err := s.DeleteRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeListRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.ListRowRequest)
		v, err := s.ListRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeExportRowEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.ExportRowRequest)
		v, err := s.ExportRow(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchCreateRowsEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchCreateRowsRequest)
		v, err := s.BatchCreateRows(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchUpdateRowsEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchUpdateRowsRequest)
		v, err := s.BatchUpdateRows(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

func MakeBatchDeleteRowsEndpoint(s pb.UnitableServer) endpoint.Endpoint {
	return func(ctx context.Context, request interface{}) (response interface{}, err error) {
		req := request.(*pb.BatchDeleteRowsRequest)
		v, err := s.BatchDeleteRows(ctx, req)
		if err != nil {
			return nil, err
		}
		return v, nil
	}
}

// WrapAllExcept wraps each Endpoint field of struct Endpoints with a
// go-kit/kit/endpoint.Middleware.
// Use this for applying a set of middlewares to every endpoint in the service.
// Optionally, endpoints can be passed in by name to be excluded from being wrapped.
// WrapAllExcept(middleware, "Status", "Ping")
func (e *Endpoints) WrapAllExcept(middleware endpoint.Middleware, excluded ...string) {
	included := map[string]struct{}{
		"create_table":         struct{}{},
		"update_table":         struct{}{},
		"get_table":            struct{}{},
		"list_tables":          struct{}{},
		"delete_table":         struct{}{},
		"sync_table":           struct{}{},
		"create_column":        struct{}{},
		"update_column":        struct{}{},
		"get_column":           struct{}{},
		"delete_column":        struct{}{},
		"list_columns":         struct{}{},
		"batch_create_columns": struct{}{},
		"batch_update_column":  struct{}{},
		"batch_delete_column":  struct{}{},
		"create_row":           struct{}{},
		"update_row":           struct{}{},
		"get_row":              struct{}{},
		"delete_row":           struct{}{},
		"list_row":             struct{}{},
		"export_row":           struct{}{},
		"batch_create_rows":    struct{}{},
		"batch_update_rows":    struct{}{},
		"batch_delete_rows":    struct{}{},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc, _ := range included {
		if inc == "create_table" {
			e.CreateTableEndpoint = middleware(e.CreateTableEndpoint)
		}
		if inc == "update_table" {
			e.UpdateTableEndpoint = middleware(e.UpdateTableEndpoint)
		}
		if inc == "get_table" {
			e.GetTableEndpoint = middleware(e.GetTableEndpoint)
		}
		if inc == "list_tables" {
			e.ListTablesEndpoint = middleware(e.ListTablesEndpoint)
		}
		if inc == "delete_table" {
			e.DeleteTableEndpoint = middleware(e.DeleteTableEndpoint)
		}
		if inc == "sync_table" {
			e.SyncTableEndpoint = middleware(e.SyncTableEndpoint)
		}
		if inc == "create_column" {
			e.CreateColumnEndpoint = middleware(e.CreateColumnEndpoint)
		}
		if inc == "update_column" {
			e.UpdateColumnEndpoint = middleware(e.UpdateColumnEndpoint)
		}
		if inc == "get_column" {
			e.GetColumnEndpoint = middleware(e.GetColumnEndpoint)
		}
		if inc == "delete_column" {
			e.DeleteColumnEndpoint = middleware(e.DeleteColumnEndpoint)
		}
		if inc == "list_columns" {
			e.ListColumnsEndpoint = middleware(e.ListColumnsEndpoint)
		}
		if inc == "batch_create_columns" {
			e.BatchCreateColumnsEndpoint = middleware(e.BatchCreateColumnsEndpoint)
		}
		if inc == "batch_update_column" {
			e.BatchUpdateColumnEndpoint = middleware(e.BatchUpdateColumnEndpoint)
		}
		if inc == "batch_delete_column" {
			e.BatchDeleteColumnEndpoint = middleware(e.BatchDeleteColumnEndpoint)
		}
		if inc == "create_row" {
			e.CreateRowEndpoint = middleware(e.CreateRowEndpoint)
		}
		if inc == "update_row" {
			e.UpdateRowEndpoint = middleware(e.UpdateRowEndpoint)
		}
		if inc == "get_row" {
			e.GetRowEndpoint = middleware(e.GetRowEndpoint)
		}
		if inc == "delete_row" {
			e.DeleteRowEndpoint = middleware(e.DeleteRowEndpoint)
		}
		if inc == "list_row" {
			e.ListRowEndpoint = middleware(e.ListRowEndpoint)
		}
		if inc == "export_row" {
			e.ExportRowEndpoint = middleware(e.ExportRowEndpoint)
		}
		if inc == "batch_create_rows" {
			e.BatchCreateRowsEndpoint = middleware(e.BatchCreateRowsEndpoint)
		}
		if inc == "batch_update_rows" {
			e.BatchUpdateRowsEndpoint = middleware(e.BatchUpdateRowsEndpoint)
		}
		if inc == "batch_delete_rows" {
			e.BatchDeleteRowsEndpoint = middleware(e.BatchDeleteRowsEndpoint)
		}
	}
}

// LabeledMiddleware will get passed the endpoint name when passed to
// WrapAllLabeledExcept, this can be used to write a generic metrics
// middleware which can send the endpoint name to the metrics collector.
type LabeledMiddleware func(string, endpoint.Endpoint) endpoint.Endpoint

// WrapAllLabeledExcept wraps each Endpoint field of struct Endpoints with a
// LabeledMiddleware, which will receive the name of the endpoint. See
// LabeldMiddleware. See method WrapAllExept for details on excluded
// functionality.
func (e *Endpoints) WrapAllLabeledExcept(middleware func(string, endpoint.Endpoint) endpoint.Endpoint, excluded ...string) {
	included := map[string]struct{}{
		"create_table":         struct{}{},
		"update_table":         struct{}{},
		"get_table":            struct{}{},
		"list_tables":          struct{}{},
		"delete_table":         struct{}{},
		"sync_table":           struct{}{},
		"create_column":        struct{}{},
		"update_column":        struct{}{},
		"get_column":           struct{}{},
		"delete_column":        struct{}{},
		"list_columns":         struct{}{},
		"batch_create_columns": struct{}{},
		"batch_update_column":  struct{}{},
		"batch_delete_column":  struct{}{},
		"create_row":           struct{}{},
		"update_row":           struct{}{},
		"get_row":              struct{}{},
		"delete_row":           struct{}{},
		"list_row":             struct{}{},
		"export_row":           struct{}{},
		"batch_create_rows":    struct{}{},
		"batch_update_rows":    struct{}{},
		"batch_delete_rows":    struct{}{},
	}

	for _, ex := range excluded {
		if _, ok := included[ex]; !ok {
			panic(fmt.Sprintf("Excluded endpoint '%s' does not exist; see middlewares/endpoints.go", ex))
		}
		delete(included, ex)
	}

	for inc, _ := range included {
		if inc == "create_table" {
			e.CreateTableEndpoint = middleware("create_table", e.CreateTableEndpoint)
		}
		if inc == "update_table" {
			e.UpdateTableEndpoint = middleware("update_table", e.UpdateTableEndpoint)
		}
		if inc == "get_table" {
			e.GetTableEndpoint = middleware("get_table", e.GetTableEndpoint)
		}
		if inc == "list_tables" {
			e.ListTablesEndpoint = middleware("list_tables", e.ListTablesEndpoint)
		}
		if inc == "delete_table" {
			e.DeleteTableEndpoint = middleware("delete_table", e.DeleteTableEndpoint)
		}
		if inc == "sync_table" {
			e.SyncTableEndpoint = middleware("sync_table", e.SyncTableEndpoint)
		}
		if inc == "create_column" {
			e.CreateColumnEndpoint = middleware("create_column", e.CreateColumnEndpoint)
		}
		if inc == "update_column" {
			e.UpdateColumnEndpoint = middleware("update_column", e.UpdateColumnEndpoint)
		}
		if inc == "get_column" {
			e.GetColumnEndpoint = middleware("get_column", e.GetColumnEndpoint)
		}
		if inc == "delete_column" {
			e.DeleteColumnEndpoint = middleware("delete_column", e.DeleteColumnEndpoint)
		}
		if inc == "list_columns" {
			e.ListColumnsEndpoint = middleware("list_columns", e.ListColumnsEndpoint)
		}
		if inc == "batch_create_columns" {
			e.BatchCreateColumnsEndpoint = middleware("batch_create_columns", e.BatchCreateColumnsEndpoint)
		}
		if inc == "batch_update_column" {
			e.BatchUpdateColumnEndpoint = middleware("batch_update_column", e.BatchUpdateColumnEndpoint)
		}
		if inc == "batch_delete_column" {
			e.BatchDeleteColumnEndpoint = middleware("batch_delete_column", e.BatchDeleteColumnEndpoint)
		}
		if inc == "create_row" {
			e.CreateRowEndpoint = middleware("create_row", e.CreateRowEndpoint)
		}
		if inc == "update_row" {
			e.UpdateRowEndpoint = middleware("update_row", e.UpdateRowEndpoint)
		}
		if inc == "get_row" {
			e.GetRowEndpoint = middleware("get_row", e.GetRowEndpoint)
		}
		if inc == "delete_row" {
			e.DeleteRowEndpoint = middleware("delete_row", e.DeleteRowEndpoint)
		}
		if inc == "list_row" {
			e.ListRowEndpoint = middleware("list_row", e.ListRowEndpoint)
		}
		if inc == "export_row" {
			e.ExportRowEndpoint = middleware("export_row", e.ExportRowEndpoint)
		}
		if inc == "batch_create_rows" {
			e.BatchCreateRowsEndpoint = middleware("batch_create_rows", e.BatchCreateRowsEndpoint)
		}
		if inc == "batch_update_rows" {
			e.BatchUpdateRowsEndpoint = middleware("batch_update_rows", e.BatchUpdateRowsEndpoint)
		}
		if inc == "batch_delete_rows" {
			e.BatchDeleteRowsEndpoint = middleware("batch_delete_rows", e.BatchDeleteRowsEndpoint)
		}
	}
}
