// Code generated by ncraft. DO NOT EDIT.
// Rerunning ncraft will overwrite this file.
// Version: 0.1.0
// Version Date:

package svc

// This file provides server-side bindings for the HTTP transport.
// It utilizes the transport/http.Server.

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"reflect"
	"strconv"
	"strings"

	"context"

	"github.com/go-kit/kit/log"
	"github.com/go-kit/kit/tracing/opentracing"
	"github.com/gorilla/mux"
	"github.com/json-iterator/go"
	"github.com/ncraft-io/ncraft/go/pkg/ncraft/logs"
	"github.com/pkg/errors"

	httptransport "github.com/go-kit/kit/transport/http"
	mjhttp "github.com/mojo-lang/http/go/pkg/mojo/http"
	pagination "github.com/ncraft-io/ncraft-gokit/pkg/pagination"
	nhttp "github.com/ncraft-io/ncraft-gokit/pkg/transport/http"
	stdopentracing "github.com/opentracing/opentracing-go"

	"github.com/mojo-lang/core/go/pkg/mojo/core"

	"github.com/ncraft-io/armory/go/pkg/armory/unitable"

	// this service api
	pb "github.com/ncraft-io/armory/go/pkg/armory/unitable/v1"
)

const contentType = "application/json; charset=utf-8"

var (
	_ = fmt.Sprint
	_ = bytes.Compare
	_ = strconv.Atoi
	_ = httptransport.NewServer
	_ = ioutil.NopCloser
	_ = pb.NewUnitableClient
	_ = io.Copy
	_ = errors.Wrap
	_ = mjhttp.UnmarshalQueryParam
)

var (
	_ = unitable.Table{}
	_ = core.Null{}
	_ = core.Ordering{}
	_ = core.FieldMask{}
	_ = unitable.Column{}
	_ = core.Object{}
)

var cfg *nhttp.Config

func init() {
	cfg = nhttp.NewConfig()
}

// RegisterHttpHandler register a set of endpoints available on predefined paths to the router.
func RegisterHttpHandler(router *mux.Router, endpoints Endpoints, tracer stdopentracing.Tracer, logger log.Logger) {
	serverOptions := []httptransport.ServerOption{
		httptransport.ServerBefore(headersToContext, queryToContext),
		httptransport.ServerErrorEncoder(errorEncoder),
		httptransport.ServerErrorLogger(logger),
		httptransport.ServerAfter(httptransport.SetContentType(contentType)),
	}

	addTracerOption := func(methodName string) []httptransport.ServerOption {
		if tracer != nil {
			return append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, methodName, logger)))
		}
		return serverOptions
	}

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables").Handler(
		httptransport.NewServer(
			endpoints.CreateTableEndpoint,
			DecodeHTTPCreateTableZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("create_table")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "create_table", logger)))...,
		))

	router.Methods("PUT").Path("/armory/unitable/v1/databases/{database}/tables/{id}").Handler(
		httptransport.NewServer(
			endpoints.UpdateTableEndpoint,
			DecodeHTTPUpdateTableZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("update_table")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "update_table", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{id}").Handler(
		httptransport.NewServer(
			endpoints.GetTableEndpoint,
			DecodeHTTPGetTableZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("get_table")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "get_table", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables").Handler(
		httptransport.NewServer(
			endpoints.ListTablesEndpoint,
			DecodeHTTPListTablesZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("list_tables")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "list_tables", logger)))...,
		))

	router.Methods("DELETE").Path("/armory/unitable/v1/databases/{database}/tables/{id}").Handler(
		httptransport.NewServer(
			endpoints.DeleteTableEndpoint,
			DecodeHTTPDeleteTableZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("delete_table")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "delete_table", logger)))...,
		))

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables/{id}:sync").Handler(
		httptransport.NewServer(
			endpoints.SyncTableEndpoint,
			DecodeHTTPSyncTableZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("sync_table")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "sync_table", logger)))...,
		))

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns").Handler(
		httptransport.NewServer(
			endpoints.CreateColumnEndpoint,
			DecodeHTTPCreateColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("create_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "create_column", logger)))...,
		))

	router.Methods("PUT").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns/{id}").Handler(
		httptransport.NewServer(
			endpoints.UpdateColumnEndpoint,
			DecodeHTTPUpdateColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("update_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "update_column", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns/{id}").Handler(
		httptransport.NewServer(
			endpoints.GetColumnEndpoint,
			DecodeHTTPGetColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("get_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "get_column", logger)))...,
		))

	router.Methods("DELETE").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns/{id}").Handler(
		httptransport.NewServer(
			endpoints.DeleteColumnEndpoint,
			DecodeHTTPDeleteColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("delete_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "delete_column", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns").Handler(
		httptransport.NewServer(
			endpoints.ListColumnsEndpoint,
			DecodeHTTPListColumnsZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("list_columns")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "list_columns", logger)))...,
		))

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchCreateColumnsEndpoint,
			DecodeHTTPBatchCreateColumnsZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_create_columns")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_create_columns", logger)))...,
		))

	router.Methods("PUT").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchUpdateColumnEndpoint,
			DecodeHTTPBatchUpdateColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_update_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_update_column", logger)))...,
		))

	router.Methods("DELETE").Path("/armory/unitable/v1/databases/{database}/tables/{table}/columns:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchDeleteColumnEndpoint,
			DecodeHTTPBatchDeleteColumnZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_delete_column")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_delete_column", logger)))...,
		))

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows").Handler(
		httptransport.NewServer(
			endpoints.CreateRowEndpoint,
			DecodeHTTPCreateRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("create_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "create_row", logger)))...,
		))

	router.Methods("PUT").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows/{id}").Handler(
		httptransport.NewServer(
			endpoints.UpdateRowEndpoint,
			DecodeHTTPUpdateRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("update_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "update_row", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows/{id}").Handler(
		httptransport.NewServer(
			endpoints.GetRowEndpoint,
			DecodeHTTPGetRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("get_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "get_row", logger)))...,
		))

	router.Methods("DELETE").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows/{id}").Handler(
		httptransport.NewServer(
			endpoints.DeleteRowEndpoint,
			DecodeHTTPDeleteRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("delete_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "delete_row", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows").Handler(
		httptransport.NewServer(
			endpoints.ListRowEndpoint,
			DecodeHTTPListRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("list_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "list_row", logger)))...,
		))

	router.Methods("GET").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows:export").Handler(
		httptransport.NewServer(
			endpoints.ExportRowEndpoint,
			DecodeHTTPExportRowZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("export_row")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "export_row", logger)))...,
		))

	router.Methods("POST").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchCreateRowsEndpoint,
			DecodeHTTPBatchCreateRowsZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_create_rows")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_create_rows", logger)))...,
		))

	router.Methods("PUT").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchUpdateRowsEndpoint,
			DecodeHTTPBatchUpdateRowsZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_update_rows")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_update_rows", logger)))...,
		))

	router.Methods("DELETE").Path("/armory/unitable/v1/databases/{database}/tables/{table}/rows:batch").Handler(
		httptransport.NewServer(
			endpoints.BatchDeleteRowsEndpoint,
			DecodeHTTPBatchDeleteRowsZeroRequest,
			EncodeHTTPGenericResponse,
			addTracerOption("batch_delete_rows")...,
		//append(serverOptions, httptransport.ServerBefore(opentracing.HTTPToContext(tracer, "batch_delete_rows", logger)))...,
		))
}

// ErrorEncoder writes the error to the ResponseWriter, by default a content
// type of application/json, a body of json with key "error" and the value
// error.Error(), and a status code of 500. If the error implements Headerer,
// the provided headers will be applied to the response. If the error
// implements json.Marshaler, and the marshaling succeeds, the JSON encoded
// form of the error will be used. If the error implements StatusCoder, the
// provided StatusCode will be used instead of 500.
func errorEncoder(ctx context.Context, err error, w http.ResponseWriter) {
	var e *core.Error
	if core.IsError(err) {
		if ce, ok := err.(*core.Error); ok {
			e = ce
		} else if ce, ok = errors.Unwrap(err).(*core.Error); ok {
			e = ce
		}
	}
	if e == nil {
		e = core.NewErrorFrom(500, err.Error())
	}

	w.Header().Set("Content-Type", contentType)
	if headerer, ok := err.(httptransport.Headerer); ok {
		for k := range headerer.Headers() {
			w.Header().Set(k, headerer.Headers().Get(k))
		}
	}

	var body []byte
	code := http.StatusInternalServerError

	if enveloped := nhttp.IsEnvelopeStyle(ctx, cfg.GetStyle()); enveloped {
		envelope := &nhttp.EnvelopedResponse{}
		envelope.Error = e

		if cfg.GetEnvelop().MappingCode {
			if sc, ok := err.(httptransport.StatusCoder); ok {
				code = sc.StatusCode()
			}
		} else {
			code = http.StatusOK
		}

		var response interface{}
		if cfg.GetEnvelop().ErrorWrapped {
			response = envelope.ToErrorWrapped()
		} else {
			response = envelope
		}

		jsonBody, marshalErr := jsoniter.ConfigFastest.Marshal(response)
		if marshalErr != nil {
			logs.Warnw("failed to marshal the error response to json", "error", marshalErr)
		} else {
			body = jsonBody
		}
	} else {
		if sc, ok := err.(httptransport.StatusCoder); ok {
			code = sc.StatusCode()
		}
		if marshaler, ok := err.(json.Marshaler); ok {
			if jsonBody, marshalErr := marshaler.MarshalJSON(); marshalErr == nil {
				body = jsonBody
			}
		}

		if jsonBody, marshalErr := jsoniter.ConfigFastest.Marshal(e); marshalErr == nil {
			body = jsonBody
		}
	}

	w.WriteHeader(code)
	w.Write(body)
}

// Server Decode

// DecodeHTTPCreateTableZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded create_table request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateTableZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.CreateTableRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Table = &unitable.Table{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Table); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	tableInitialized := false
	if req.Table == nil {
		tableInitialized = true
		req.Table = &unitable.Table{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Table, "table")
	if err != nil {
		if core.IsNotFoundError(err) {
			if tableInitialized {
				req.Table = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
		}
	}

	return &req, nil
}

// DecodeHTTPUpdateTableZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded update_table request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateTableZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.UpdateTableRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Table = &unitable.Table{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Table); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	tableInitialized := false
	if req.Table == nil {
		tableInitialized = true
		req.Table = &unitable.Table{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Table, "table")
	if err != nil {
		if core.IsNotFoundError(err) {
			if tableInitialized {
				req.Table = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
		}
	}

	return &req, nil
}

// DecodeHTTPGetTableZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded get_table request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetTableZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.GetTableRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	return &req, nil
}

// DecodeHTTPListTablesZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded list_tables request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListTablesZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.ListTablesRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	fieldMaskInitialized := false
	if req.FieldMask == nil {
		fieldMaskInitialized = true
		req.FieldMask = &core.FieldMask{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.FieldMask, "field_mask")
	if err != nil {
		if core.IsNotFoundError(err) {
			if fieldMaskInitialized {
				req.FieldMask = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the field_mask  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Filter, "filter")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the filter  query parameter")
	}

	orderInitialized := false
	if req.Order == nil {
		orderInitialized = true
		req.Order = &core.Ordering{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Order, "order")
	if err != nil {
		if core.IsNotFoundError(err) {
			if orderInitialized {
				req.Order = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the order  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageSize, "page_size")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_size  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageToken, "page_token")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_token  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Skip, "skip")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the skip  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Unique, "unique")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the unique  query parameter")
	}

	return &req, nil
}

// DecodeHTTPDeleteTableZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded delete_table request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteTableZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.DeleteTableRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Force, "force")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the force  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	return &req, nil
}

// DecodeHTTPSyncTableZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded sync_table request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPSyncTableZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.SyncTableRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	return &req, nil
}

// DecodeHTTPCreateColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded create_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.CreateColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Column = &unitable.Column{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Column); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	columnInitialized := false
	if req.Column == nil {
		columnInitialized = true
		req.Column = &unitable.Column{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Column, "column")
	if err != nil {
		if core.IsNotFoundError(err) {
			if columnInitialized {
				req.Column = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the column  query parameter")
		}
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPUpdateColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded update_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.UpdateColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Column = &unitable.Column{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Column); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	columnInitialized := false
	if req.Column == nil {
		columnInitialized = true
		req.Column = &unitable.Column{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Column, "column")
	if err != nil {
		if core.IsNotFoundError(err) {
			if columnInitialized {
				req.Column = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the column  query parameter")
		}
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPGetColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded get_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.GetColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPDeleteColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded delete_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.DeleteColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPListColumnsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded list_columns request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListColumnsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.ListColumnsRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	fieldMaskInitialized := false
	if req.FieldMask == nil {
		fieldMaskInitialized = true
		req.FieldMask = &core.FieldMask{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.FieldMask, "field_mask")
	if err != nil {
		if core.IsNotFoundError(err) {
			if fieldMaskInitialized {
				req.FieldMask = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the field_mask  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Filter, "filter")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the filter  query parameter")
	}

	orderInitialized := false
	if req.Order == nil {
		orderInitialized = true
		req.Order = &core.Ordering{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Order, "order")
	if err != nil {
		if core.IsNotFoundError(err) {
			if orderInitialized {
				req.Order = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the order  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageSize, "page_size")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_size  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageToken, "page_token")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_token  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Skip, "skip")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the skip  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Unique, "unique")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the unique  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchCreateColumnsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_create_columns request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchCreateColumnsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchCreateColumnsRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Columns = []*unitable.Column{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req.Columns); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Columns, "columns")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the columns  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchUpdateColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_update_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchUpdateColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchUpdateColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Columns = []*unitable.Column{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req.Columns); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Columns, "columns")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the columns  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchDeleteColumnZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_delete_column request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchDeleteColumnZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchDeleteColumnRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Ids, "ids")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the ids  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPCreateRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded create_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPCreateRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.CreateRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Row = &core.Object{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Row); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	rowInitialized := false
	if req.Row == nil {
		rowInitialized = true
		req.Row = &core.Object{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Row, "row")
	if err != nil {
		if core.IsNotFoundError(err) {
			if rowInitialized {
				req.Row = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the row  query parameter")
		}
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPUpdateRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded update_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPUpdateRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.UpdateRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Row = &core.Object{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, req.Row); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	rowInitialized := false
	if req.Row == nil {
		rowInitialized = true
		req.Row = &core.Object{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Row, "row")
	if err != nil {
		if core.IsNotFoundError(err) {
			if rowInitialized {
				req.Row = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the row  query parameter")
		}
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPGetRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded get_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPGetRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.GetRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPDeleteRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded delete_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPDeleteRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.DeleteRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Id, "id")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the id  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPListRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded list_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPListRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.ListRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	fieldMaskInitialized := false
	if req.FieldMask == nil {
		fieldMaskInitialized = true
		req.FieldMask = &core.FieldMask{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.FieldMask, "field_mask")
	if err != nil {
		if core.IsNotFoundError(err) {
			if fieldMaskInitialized {
				req.FieldMask = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the field_mask  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Filter, "filter")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the filter  query parameter")
	}

	orderInitialized := false
	if req.Order == nil {
		orderInitialized = true
		req.Order = &core.Ordering{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Order, "order")
	if err != nil {
		if core.IsNotFoundError(err) {
			if orderInitialized {
				req.Order = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the order  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageSize, "page_size")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_size  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageToken, "page_token")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_token  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Query, "query")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the query  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Skip, "skip")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the skip  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Unique, "unique")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the unique  query parameter")
	}

	return &req, nil
}

// DecodeHTTPExportRowZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded export_row request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPExportRowZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.ExportRowRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	fieldMaskInitialized := false
	if req.FieldMask == nil {
		fieldMaskInitialized = true
		req.FieldMask = &core.FieldMask{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.FieldMask, "field_mask")
	if err != nil {
		if core.IsNotFoundError(err) {
			if fieldMaskInitialized {
				req.FieldMask = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the field_mask  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Filter, "filter")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the filter  query parameter")
	}

	orderInitialized := false
	if req.Order == nil {
		orderInitialized = true
		req.Order = &core.Ordering{}
	}
	err = mjhttp.UnmarshalQueryParam(queryParams, req.Order, "order")
	if err != nil {
		if core.IsNotFoundError(err) {
			if orderInitialized {
				req.Order = nil
			}
		} else {
			return nil, nhttp.WrapError(err, 400, "cannot unmarshal the order  query parameter")
		}
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageSize, "page_size")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_size  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.PageToken, "page_token")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the page_token  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Skip, "skip")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the skip  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Unique, "unique")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the unique  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchCreateRowsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_create_rows request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchCreateRowsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchCreateRowsRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Rows = []*core.Object{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req.Rows); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Rows, "rows")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the rows  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchUpdateRowsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_update_rows request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchUpdateRowsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchUpdateRowsRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		req.Rows = []*core.Object{}
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req.Rows); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Rows, "rows")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the rows  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// DecodeHTTPBatchDeleteRowsZeroRequest is a transport/http.DecodeRequestFunc that
// decodes a JSON-encoded batch_delete_rows request from the HTTP request
// body. Primarily useful in a server.
func DecodeHTTPBatchDeleteRowsZeroRequest(_ context.Context, r *http.Request) (interface{}, error) {
	var req pb.BatchDeleteRowsRequest

	// to support gzip input
	var reader io.ReadCloser
	var err error
	switch r.Header.Get("Content-Encoding") {
	case "gzip":
		reader, err = gzip.NewReader(r.Body)
		defer reader.Close()
		if err != nil {
			return nil, nhttp.WrapError(err, 400, "failed to read the gzip content")
		}
	default:
		reader = r.Body
	}

	buf, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, nhttp.WrapError(err, 400, "cannot read body of http request")
	}
	if len(buf) > 0 {
		if err = jsoniter.ConfigFastest.Unmarshal(buf, &req); err != nil {
			const size = 8196
			if len(buf) > size {
				buf = buf[:size]
			}
			return nil, nhttp.WrapError(err,
				http.StatusBadRequest,
				fmt.Sprintf("request body '%s': cannot parse non-json request body", buf),
			)
		}
	}

	pathParams := mux.Vars(r)
	_ = pathParams

	queryParams := core.NewUrlQueryFrom(r.URL.Query())
	_ = queryParams

	parsedQueryParams := make(map[string]bool)
	_ = parsedQueryParams

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Database, "database")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the database  query parameter")
	}

	err = mjhttp.UnmarshalQueryParam(queryParams, &req.Ids, "ids")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the ids  query parameter")
	}

	err = mjhttp.UnmarshalPathParam(pathParams, &req.Table, "table")
	if err != nil && !core.IsNotFoundError(err) {
		return nil, nhttp.WrapError(err, 400, "cannot unmarshal the table  query parameter")
	}

	return &req, nil
}

// EncodeHTTPGenericResponse is a transport/http.EncodeResponseFunc that encodes
// the response as JSON to the response writer. Primarily useful in a server.
func EncodeHTTPGenericResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error {
	if writer, ok := response.(nhttp.ResponseWriter); ok {
		return writer.WriteHttpResponse(ctx, w)
	}

	if reflect.ValueOf(response).IsNil() {
		response = nil
	}
	if _, ok := response.(*core.Null); ok {
		response = nil
	}

	enveloped := nhttp.IsEnvelopeStyle(ctx, cfg.GetStyle())
	if enveloped {
		code := core.NewErrorCode(200)
		message := "OK"
		if sc := cfg.GetEnvelop().SuccessCode; len(sc) > 0 {
			if c, err := core.ParseErrorCode(sc); err != nil {
				logs.Warnw("failed to parse the user setting success code, will use \"200\" indeed.", "code", sc, "error", err)
			} else {
				code = c
			}
		}
		if msg := cfg.GetEnvelop().SuccessMessage; len(msg) > 0 {
			message = msg
		}

		if response == nil {
			response = &nhttp.EnvelopedResponse{
				Error: &core.Error{
					Code:    code,
					Message: message,
				},
			}
		} else {
			totalCount := int32(0)
			nextPageToken := ""
			if p, ok := response.(pagination.Paginater); ok {
				totalCount = p.GetTotalCount()
				nextPageToken = p.GetNextPageToken()
			}

			response = &nhttp.EnvelopedResponse{
				Error: &core.Error{
					Code:    code,
					Message: message,
				},
				TotalCount:    totalCount,
				NextPageToken: nextPageToken,
				Data:          response,
			}
		}
	} else if response != nil {
		if p, ok := response.(pagination.Paginater); ok {
			total := p.GetTotalCount()
			if total > 0 {
				w.Header().Set("X-Total-Count", strconv.Itoa(int(total)))
			}

			next := p.GetNextPageToken()
			if len(next) > 0 {
				path, _ := ctx.Value("http-request-path").(string)
				if len(path) == 0 {
					path = "/?next-page-token=" + next
				} else {
					url, _ := core.ParseUrl(path)
					url.Query.Add("next-page-token", next)
					path = url.Format()
				}
				w.Header().Set("Link", fmt.Sprintf("<%s>; rel=\"next\"", path))
			}
		}
	}

	if response == nil {
		return nil
	}

	return nhttp.NewResponseJsonWriter(response).WriteHttpResponse(ctx, w)
}

// Helper functions

func headersToContext(ctx context.Context, r *http.Request) context.Context {
	for k, _ := range r.Header {
		// The key is added both in http format (k) which has had
		// http.CanonicalHeaderKey called on it in transport as well as the
		// strings.ToLower which is the grpc metadata format of the key so
		// that it can be accessed in either format
		ctx = context.WithValue(ctx, k, r.Header.Get(k))
		ctx = context.WithValue(ctx, strings.ToLower(k), r.Header.Get(k))
	}

	// add the access key to context
	accessKey := r.URL.Query().Get("access_key")
	if len(accessKey) > 0 {
		ctx = context.WithValue(ctx, "access_key", accessKey)
	}

	// Tune specific change.
	// also add the request url
	ctx = context.WithValue(ctx, "http-request-path", r.URL.Path)
	ctx = context.WithValue(ctx, "transport", "HTTPJSON")

	return ctx
}

func queryToContext(ctx context.Context, r *http.Request) context.Context {
	check := func(values []string) bool {
		for _, value := range values {
			if value == "true" {
				return true
			}
		}
		return false
	}
	for key, values := range r.URL.Query() {
		switch key {
		case "envelope":
			if check(values) {
				ctx = context.WithValue(ctx, "envelope", true)
			}
		}
	}
	return ctx
}
